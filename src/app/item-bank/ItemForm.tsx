'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { AxiosError } from 'axios';
import {
  Box,
  Button,
  TextField,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Paper,
  Grid,
  Alert,
  Typography,
  List,
  ListItem,
  IconButton,
  Divider,
} from '@mui/material';
import { Add as AddIcon, Delete as DeleteIcon } from '@mui/icons-material';
import { useFormik } from 'formik';
import * as yup from 'yup';
import type { QTIInteractionType, QTIAssessmentItem } from '@/types/qti';
import { assessmentItemService } from '@/lib/api/services';

const interactionTypes: QTIInteractionType[] = [
  'choice',
  'text-entry',
  'extended-text',
  'inline-choice',
  'match',
  'order',
  'associate',
  'select-point',
  'graphic-order',
  'graphic-associate',
  'graphic-gap-match',
  'hotspot',
  'slider',
  'drawing',
  'media',
  'custom',
  'upload',
];

const validationSchema = yup.object({
  title: yup.string().required('Title is required'),
  type: yup.string().required('Interaction type is required'),
  prompt: yup.string().required('Prompt is required'),
});

interface ItemFormProps {
  initialValues?: Partial<QTIAssessmentItem>;
  onSubmit?: (values: QTIAssessmentItem) => Promise<void>;
}

export default function ItemForm({ initialValues, onSubmit }: ItemFormProps) {
  const router = useRouter();
  const [error, setError] = useState<string | null>(null);
  const [choices, setChoices] = useState<Array<{ identifier: string; value: string }>>([]);

  const formik = useFormik({
    initialValues: {
      title: initialValues?.title || '',
      type: initialValues?.type || 'choice',
      prompt: initialValues?.interaction?.prompt || '',
      questionStructure: initialValues?.interaction?.questionStructure || {
        prompt: '',
        choices: [],
      },
    },
    validationSchema,
    onSubmit: async (values) => {
      try {
        const itemData: Omit<QTIAssessmentItem, 'identifier'> = {
          title: values.title,
          type: values.type as QTIInteractionType,
          interaction: {
            type: values.type as QTIInteractionType,
            prompt: values.prompt,
            responseIdentifier: 'RESPONSE',
            shuffle: true,
            maxChoices: 1,
            questionStructure: {
              prompt: values.prompt,
              choices: choices.map(choice => ({
                identifier: choice.identifier,
                content: choice.value.trim(),
                text: choice.value.trim(),
              })).filter(choice => choice.content !== ''),
            },
          },
          responseDeclaration: {
            identifier: 'RESPONSE',
            cardinality: 'single',
            baseType: 'identifier',
            correctResponse: {
              value: choices.length > 0 ? [choices[0].identifier] : [],
            },
          },
          rawXml: '',  // Will be generated by the server
          content: {}, // Will be populated by the server
          metadata: {},
        };

        if (onSubmit) {
          await onSubmit(itemData as QTIAssessmentItem);
        } else {
          await assessmentItemService.create(itemData);
          router.push('/item-bank');
        }
      } catch (err) {
        console.error('Error saving item:', err);
        const axiosError = err as AxiosError<{ error: string; details?: string }>;
        if (axiosError.response?.data?.error) {
          setError(axiosError.response.data.error + (axiosError.response.data.details ? `: ${axiosError.response.data.details}` : ''));
        } else {
          setError(err instanceof Error ? err.message : 'Failed to save item');
        }
      }
    },
  });

  const handleAddChoice = () => {
    const newChoice = {
      identifier: `CHOICE_${choices.length + 1}`,
      value: '',
    };
    setChoices([...choices, newChoice]);
  };

  const handleRemoveChoice = (index: number) => {
    const newChoices = [...choices];
    newChoices.splice(index, 1);
    setChoices(newChoices);
  };

  const handleChoiceChange = (index: number, value: string) => {
    const newChoices = [...choices];
    newChoices[index] = { ...newChoices[index], value };
    setChoices(newChoices);
  };

  const renderInteractionOptions = () => {
    switch (formik.values.type) {
      case 'choice':
        return (
          <Box sx={{ mt: 2 }}>
            <Box sx={{ mb: 2, display: 'flex', alignItems: 'center', gap: 2 }}>
              <Typography variant="subtitle1">Choices</Typography>
              <Button
                startIcon={<AddIcon />}
                onClick={handleAddChoice}
                variant="outlined"
                size="small"
              >
                Add Choice
              </Button>
            </Box>
            <List>
              {choices.map((choice, index) => (
                <ListItem key={choice.identifier} sx={{ px: 0 }}>
                  <TextField
                    fullWidth
                    label={`Choice ${index + 1}`}
                    value={choice.value}
                    onChange={(e) => handleChoiceChange(index, e.target.value)}
                    sx={{ mr: 2 }}
                  />
                  <IconButton
                    edge="end"
                    aria-label="delete"
                    onClick={() => handleRemoveChoice(index)}
                  >
                    <DeleteIcon />
                  </IconButton>
                </ListItem>
              ))}
            </List>
          </Box>
        );
      // Add more interaction type renderers here
      default:
        return null;
    }
  };

  return (
    <Paper sx={{ p: 4 }}>
      {error && (
        <Alert severity="error" sx={{ mb: 3 }}>
          {error}
        </Alert>
      )}

      <form onSubmit={formik.handleSubmit}>
        <Grid container spacing={3}>
          <Grid item xs={12}>
            <TextField
              fullWidth
              id="title"
              name="title"
              label="Title"
              value={formik.values.title}
              onChange={formik.handleChange}
              error={formik.touched.title && Boolean(formik.errors.title)}
              helperText={formik.touched.title && formik.errors.title}
            />
          </Grid>

          <Grid item xs={12}>
            <FormControl fullWidth>
              <InputLabel id="type-label">Interaction Type</InputLabel>
              <Select
                labelId="type-label"
                id="type"
                name="type"
                value={formik.values.type}
                label="Interaction Type"
                onChange={formik.handleChange}
              >
                {interactionTypes.map((type) => (
                  <MenuItem key={type} value={type}>
                    {type.replace(/-/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase())}
                  </MenuItem>
                ))}
              </Select>
            </FormControl>
          </Grid>

          <Grid item xs={12}>
            <TextField
              fullWidth
              id="prompt"
              name="prompt"
              label="Question Prompt"
              multiline
              rows={4}
              value={formik.values.prompt}
              onChange={formik.handleChange}
              error={formik.touched.prompt && Boolean(formik.errors.prompt)}
              helperText={formik.touched.prompt && formik.errors.prompt}
            />
          </Grid>

          <Grid item xs={12}>
            <Divider sx={{ my: 2 }} />
            {renderInteractionOptions()}
          </Grid>

          <Grid item xs={12}>
            <Box sx={{ display: 'flex', gap: 2, justifyContent: 'flex-end' }}>
              <Button
                variant="outlined"
                onClick={() => router.back()}
              >
                Cancel
              </Button>
              <Button
                type="submit"
                variant="contained"
                disabled={formik.isSubmitting}
              >
                Save Item
              </Button>
            </Box>
          </Grid>
        </Grid>
      </form>
    </Paper>
  );
} 